# calculate the stirling numbers of the second kind
# the output of stirling() is a zero-based array for substantive reasons,
# so to pull out the appropriate values in a 1-based array index language, add one to
# all indices...
stirl <- stirling(n)
col <- stirl[subsets_selected + 1]
# since this is a data frame, pad the rest of the column with NA
num_NA_needed <- max_rows - length(col)
col <- c(col, rep(NA_integer_, num_NA_needed))
subsets <- cbind(subsets, col)
}
colnames(subsets) <- cnames
ex_num_sol_init <- c(3,4,6,8)
assem <- c(20, 30, 40, 60)
max_assem = max(assem)
max_rows = length(seq(from=10, to=max_assem/2, by=10)) + length(ex_num_sol_init)
print(max_rows)
cnames <-c("Subset Size")
subsets <- data.frame(matrix())
# The subset sizes are the first column
subsets <- cbind(subsets, ex_num_sol)
# Create columns for each assemblage size, picking out the {n,k} for the desired subset sizes
for(n in assem) {
# add the assemblage size as a colname
cnames <- c(cnames, as.character(n))
# calculate additional subset sizes based on the size of the assemblage, up to 1/2*N since {n,k} peaks there
more_subsets <- seq(from=10, to=n/2, by=10)
subsets_selected <- c(ex_num_sol_init, more_subsets)
# calculate the stirling numbers of the second kind
# the output of stirling() is a zero-based array for substantive reasons,
# so to pull out the appropriate values in a 1-based array index language, add one to
# all indices...
stirl <- stirling(n)
col <- stirl[subsets_selected + 1]
# since this is a data frame, pad the rest of the column with NA
num_NA_needed <- max_rows - length(col)
col <- c(col, rep(NA_integer_, num_NA_needed))
subsets <- cbind(subsets, col)
}
colnames(subsets) <- cnames
ex_num_sol_init <- c(3,4,6,8)
assem <- c(20, 40, 60)
max_assem = max(assem)
max_rows = length(seq(from=10, to=max_assem/2, by=10)) + length(ex_num_sol_init)
print(max_rows)
cnames <-c("Subset Size")
subsets <- data.frame(matrix())
# The subset sizes are the first column
subsets <- cbind(subsets, ex_num_sol)
# Create columns for each assemblage size, picking out the {n,k} for the desired subset sizes
for(n in assem) {
# add the assemblage size as a colname
cnames <- c(cnames, as.character(n))
# calculate additional subset sizes based on the size of the assemblage, up to 1/2*N since {n,k} peaks there
more_subsets <- seq(from=10, to=n/2, by=10)
subsets_selected <- c(ex_num_sol_init, more_subsets)
# calculate the stirling numbers of the second kind
# the output of stirling() is a zero-based array for substantive reasons,
# so to pull out the appropriate values in a 1-based array index language, add one to
# all indices...
stirl <- stirling(n)
col <- stirl[subsets_selected + 1]
# since this is a data frame, pad the rest of the column with NA
num_NA_needed <- max_rows - length(col)
col <- c(col, rep(NA_integer_, num_NA_needed))
subsets <- cbind(subsets, col)
}
colnames(subsets) <- cnames
ex_num_sol_init <- c(3,4,6,8)
assem <- c(20, 40, 60)
max_assem = max(assem)
max_rows = length(seq(from=10, to=max_assem/2, by=10)) + length(ex_num_sol_init)
print(max_rows)
cnames <-c("Subset Size")
subsets <- data.frame(matrix())
# The subset sizes are the first column
subsets <- cbind(subsets, ex_num_sol)
# Create columns for each assemblage size, picking out the {n,k} for the desired subset sizes
for(n in assem) {
# add the assemblage size as a colname
cnames <- c(cnames, as.character(n))
# calculate additional subset sizes based on the size of the assemblage, up to 1/2*N since {n,k} peaks there
more_subsets <- seq(from=10, to=n/2, by=10)
subsets_selected <- c(ex_num_sol_init, more_subsets)
print(paste("num subsets selected: ",length(subsets_selected)))
# calculate the stirling numbers of the second kind
# the output of stirling() is a zero-based array for substantive reasons,
# so to pull out the appropriate values in a 1-based array index language, add one to
# all indices...
stirl <- stirling(n)
col <- stirl[subsets_selected + 1]
# since this is a data frame, pad the rest of the column with NA
num_NA_needed <- max_rows - length(col)
col <- c(col, rep(NA_integer_, num_NA_needed))
subsets <- cbind(subsets, col)
}
colnames(subsets) <- cnames
# ncol=0,nrow=numrows
ex_num_sol_init <- c(3,4,6,8)
assem <- c(20, 40, 60)
max_assem = max(assem)
max_rows = length(seq(from=10, to=max_assem/2, by=10)) + length(ex_num_sol_init)
print(max_rows)
cnames <-c("Subset Size")
subsets <- data.frame(matrix(ncol=0,nrow=max_rows))
# The subset sizes are the first column
subsets <- cbind(subsets, ex_num_sol)
# Create columns for each assemblage size, picking out the {n,k} for the desired subset sizes
for(n in assem) {
# add the assemblage size as a colname
cnames <- c(cnames, as.character(n))
# calculate additional subset sizes based on the size of the assemblage, up to 1/2*N since {n,k} peaks there
more_subsets <- seq(from=10, to=n/2, by=10)
subsets_selected <- c(ex_num_sol_init, more_subsets)
print(paste("num subsets selected: ",length(subsets_selected)))
# calculate the stirling numbers of the second kind
# the output of stirling() is a zero-based array for substantive reasons,
# so to pull out the appropriate values in a 1-based array index language, add one to
# all indices...
stirl <- stirling(n)
col <- stirl[subsets_selected + 1]
# since this is a data frame, pad the rest of the column with NA
num_NA_needed <- max_rows - length(col)
col <- c(col, rep(NA_integer_, num_NA_needed))
subsets <- cbind(subsets, col)
}
colnames(subsets) <- cnames
ex_num_sol_init <- c(3,4,6,8)
assem <- c(20, 40, 60)
max_assem = max(assem)
max_rows = length(seq(from=10, to=max_assem/2, by=10)) + length(ex_num_sol_init)
print(max_rows)
cnames <-c("Subset Size")
subsets <- data.frame(matrix(ncol=0,nrow=max_rows))
# The subset sizes are the first column
subsets <- cbind(subsets, ex_num_sol)
# Create columns for each assemblage size, picking out the {n,k} for the desired subset sizes
for(n in assem) {
# add the assemblage size as a colname
cnames <- c(cnames, as.character(n))
# calculate additional subset sizes based on the size of the assemblage, up to 1/2*N since {n,k} peaks there
more_subsets <- seq(from=10, to=n/2, by=10)
subsets_selected <- c(ex_num_sol_init, more_subsets)
print(paste("num subsets selected: ",length(subsets_selected)))
# calculate the stirling numbers of the second kind
# the output of stirling() is a zero-based array for substantive reasons,
# so to pull out the appropriate values in a 1-based array index language, add one to
# all indices...
stirl <- stirling(n)
col <- stirl[subsets_selected + 1]
# since this is a data frame, pad the rest of the column with NA
num_NA_needed <- max_rows - length(col)
col <- c(col, rep(NA_integer_, num_NA_needed))
subsets <- cbind(subsets, col)
}
viewData(subsets)
viewData(subsets)
ex_num_sol_init <- c(3,4,6,8)
assem <- c(20, 40, 60)
max_assem = max(assem)
max_subset_labels <- c(ex_num_sol_init, seq(from=10, to=max_assem/2, by=10))
max_rows <- length(max_subset_labels)
print(max_rows)
cnames <-c("Subset Size")
subsets <- data.frame(matrix(ncol=0,nrow=max_rows))
# The subset sizes are the first column
subsets <- cbind(subsets, max_subset_labels)
# Create columns for each assemblage size, picking out the {n,k} for the desired subset sizes
for(n in assem) {
# add the assemblage size as a colname
cnames <- c(cnames, as.character(n))
# calculate additional subset sizes based on the size of the assemblage, up to 1/2*N since {n,k} peaks there
more_subsets <- seq(from=10, to=n/2, by=10)
subsets_selected <- c(ex_num_sol_init, more_subsets)
print(paste("num subsets selected: ",length(subsets_selected)))
# calculate the stirling numbers of the second kind
# the output of stirling() is a zero-based array for substantive reasons,
# so to pull out the appropriate values in a 1-based array index language, add one to
# all indices...
stirl <- stirling(n)
col <- stirl[subsets_selected + 1]
# since this is a data frame, pad the rest of the column with NA
num_NA_needed <- max_rows - length(col)
col <- c(col, rep(NA_integer_, num_NA_needed))
subsets <- cbind(subsets, col)
}
colnames(subsets) <- cnames
viewData(subsets)
viewData(subsets)
ex_num_sol_init <- c(3,4,6,8)
assem <- c(20, 30, 40, 50, 60)
max_assem = max(assem)
max_subset_labels <- c(ex_num_sol_init, seq(from=10, to=max_assem/2, by=10))
max_rows <- length(max_subset_labels)
print(max_rows)
cnames <-c("Subset Size")
subsets <- data.frame(matrix(ncol=0,nrow=max_rows))
# The subset sizes are the first column
subsets <- cbind(subsets, max_subset_labels)
# Create columns for each assemblage size, picking out the {n,k} for the desired subset sizes
for(n in assem) {
# add the assemblage size as a colname
cnames <- c(cnames, as.character(n))
# calculate additional subset sizes based on the size of the assemblage, up to 1/2*N since {n,k} peaks there
more_subsets <- seq(from=10, to=n/2, by=10)
subsets_selected <- c(ex_num_sol_init, more_subsets)
print(paste("num subsets selected: ",length(subsets_selected)))
# calculate the stirling numbers of the second kind
# the output of stirling() is a zero-based array for substantive reasons,
# so to pull out the appropriate values in a 1-based array index language, add one to
# all indices...
stirl <- stirling(n)
col <- stirl[subsets_selected + 1]
# since this is a data frame, pad the rest of the column with NA
num_NA_needed <- max_rows - length(col)
col <- c(col, rep(NA_integer_, num_NA_needed))
subsets <- cbind(subsets, col)
}
colnames(subsets) <- cnames
viewData(subsets)
viewData(subsets)
ex_num_sol_init <- c(3,4,6,8)
assem <- c(20, 40)
max_assem = max(assem)
max_subset_labels <- c(ex_num_sol_init, seq(from=10, to=max_assem/2, by=10))
max_rows <- length(max_subset_labels)
print(max_rows)
cnames <-c("Subset Size")
subsets <- data.frame(matrix(ncol=0,nrow=max_rows))
# The subset sizes are the first column
subsets <- cbind(subsets, max_subset_labels)
# Create columns for each assemblage size, picking out the {n,k} for the desired subset sizes
for(n in assem) {
# add the assemblage size as a colname
cnames <- c(cnames, as.character(n))
# calculate additional subset sizes based on the size of the assemblage, up to 1/2*N since {n,k} peaks there
more_subsets <- seq(from=10, to=n/2, by=5)
subsets_selected <- c(ex_num_sol_init, more_subsets)
print(paste("num subsets selected: ",length(subsets_selected)))
# calculate the stirling numbers of the second kind
# the output of stirling() is a zero-based array for substantive reasons,
# so to pull out the appropriate values in a 1-based array index language, add one to
# all indices...
stirl <- stirling(n)
col <- stirl[subsets_selected + 1]
# since this is a data frame, pad the rest of the column with NA
num_NA_needed <- max_rows - length(col)
col <- c(col, rep(NA_integer_, num_NA_needed))
subsets <- cbind(subsets, col)
}
colnames(subsets) <- cnames
ex_num_sol_init <- c(3,4,6,8)
assem <- c(20, 40)
max_assem = max(assem)
max_subset_labels <- c(ex_num_sol_init, seq(from=10, to=max_assem/2, by=10))
max_rows <- length(max_subset_labels)
print(max_rows)
cnames <-c("Subset Size")
subsets <- data.frame(matrix(ncol=0,nrow=max_rows))
# The subset sizes are the first column
subsets <- cbind(subsets, max_subset_labels)
# Create columns for each assemblage size, picking out the {n,k} for the desired subset sizes
for(n in assem) {
# add the assemblage size as a colname
cnames <- c(cnames, as.character(n))
# calculate additional subset sizes based on the size of the assemblage, up to 1/2*N since {n,k} peaks there
more_subsets <- seq(from=10, to=n/2, by=5)
subsets_selected <- c(ex_num_sol_init, more_subsets)
print(paste("num subsets selected: ",length(subsets_selected)))
# calculate the stirling numbers of the second kind
# the output of stirling() is a zero-based array for substantive reasons,
# so to pull out the appropriate values in a 1-based array index language, add one to
# all indices...
stirl <- stirling(n)
col <- stirl[subsets_selected + 1]
# since this is a data frame, pad the rest of the column with NA
num_NA_needed <- max_rows - length(col)
col <- c(col, rep(NA_integer_, num_NA_needed))
subsets <- cbind(subsets, col)
}
colnames(subsets) <- cnames
viewData(subsets)
viewData(subsets)
# ncol=0,nrow=numrows
ex_num_sol_init <- c(3,4,6,8)
assem <- c(20, 40, 60)
max_assem = max(assem)
max_subset_labels <- c(ex_num_sol_init, seq(from=10, to=max_assem/2, by=10))
max_rows <- length(max_subset_labels)
print(max_rows)
cnames <-c("Subset Size")
subsets <- data.frame(matrix(ncol=0,nrow=max_rows))
# The subset sizes are the first column
subsets <- cbind(subsets, max_subset_labels)
# Create columns for each assemblage size, picking out the {n,k} for the desired subset sizes
for(n in assem) {
# add the assemblage size as a colname
cnames <- c(cnames, as.character(n))
# calculate additional subset sizes based on the size of the assemblage, up to 1/2*N since {n,k} peaks there
more_subsets <- seq(from=10, to=n/2, by=5)
subsets_selected <- c(ex_num_sol_init, more_subsets)
print(paste("num subsets selected: ",length(subsets_selected)))
# calculate the stirling numbers of the second kind
# the output of stirling() is a zero-based array for substantive reasons,
# so to pull out the appropriate values in a 1-based array index language, add one to
# all indices...
stirl <- stirling(n)
col <- stirl[subsets_selected + 1]
# since this is a data frame, pad the rest of the column with NA
num_NA_needed <- max_rows - length(col)
col <- c(col, rep(NA_integer_, num_NA_needed))
subsets <- cbind(subsets, col)
}
colnames(subsets) <- cnames
ex_num_sol_init <- c(3,4,6,8)
assem <- c(20, 40, 60)
max_assem = max(assem)
max_subset_labels <- c(ex_num_sol_init, seq(from=10, to=max_assem/2, by=10))
max_rows <- length(max_subset_labels)
print(max_rows)
cnames <-c("Subset Size")
subsets <- data.frame(matrix(ncol=0,nrow=max_rows))
# The subset sizes are the first column
subsets <- cbind(subsets, max_subset_labels)
# Create columns for each assemblage size, picking out the {n,k} for the desired subset sizes
for(n in assem) {
# add the assemblage size as a colname
cnames <- c(cnames, as.character(n))
# calculate additional subset sizes based on the size of the assemblage, up to 1/2*N since {n,k} peaks there
more_subsets <- seq(from=10, to=n/2, by=10)
subsets_selected <- c(ex_num_sol_init, more_subsets)
print(paste("num subsets selected: ",length(subsets_selected)))
# calculate the stirling numbers of the second kind
# the output of stirling() is a zero-based array for substantive reasons,
# so to pull out the appropriate values in a 1-based array index language, add one to
# all indices...
stirl <- stirling(n)
col <- stirl[subsets_selected + 1]
# since this is a data frame, pad the rest of the column with NA
num_NA_needed <- max_rows - length(col)
col <- c(col, rep(NA_integer_, num_NA_needed))
subsets <- cbind(subsets, col)
}
colnames(subsets) <- cnames
capt <- paste("Number of unique seriation solutions and processing time for sets of assemblages 4 < n < 100, testing solutions across",parallelism,"cores",sep=" ")
xt2 <- xtable(sscomb, align="|c|c|r|r|r|", display=c("d","d","g","g","g"),caption=capt)
print(xt2, include.rownames=FALSE)
viewData(subsets)
viewData(subsets)
ex_num_sol_init <- c(3,4,6,8)
assem <- c(20, 40, 60)
max_assem = max(assem)
max_subset_labels <- c(ex_num_sol_init, seq(from=10, to=max_assem/2, by=10))
max_rows <- length(max_subset_labels)
print(max_rows)
cnames <-c("Subset Size")
subsets <- data.frame(matrix(ncol=0,nrow=max_rows))
# The subset sizes are the first column
subsets <- cbind(subsets, max_subset_labels)
# Create columns for each assemblage size, picking out the {n,k} for the desired subset sizes
for(n in assem) {
# add the assemblage size as a colname
cnames <- c(cnames, as.character(n))
# calculate additional subset sizes based on the size of the assemblage, up to 1/2*N since {n,k} peaks there
more_subsets <- seq(from=10, to=n/2, by=10)
subsets_selected <- c(ex_num_sol_init, more_subsets)
print(paste("num subsets selected: ",length(subsets_selected)))
# calculate the stirling numbers of the second kind
# the output of stirling() is a zero-based array for substantive reasons,
# so to pull out the appropriate values in a 1-based array index language, add one to
# all indices...
stirl <- stirling(n)
col <- stirl[subsets_selected + 1]
# since this is a data frame, pad the rest of the column with NA
num_NA_needed <- max_rows - length(col)
col <- c(col, rep(NA_integer_, num_NA_needed))
subsets <- cbind(subsets, col)
}
colnames(subsets) <- cnames
capt2 <- paste("Number of ways to form M seriation solutions from 20-60 assemblages")
xt3 <- xtable(subsets, align="|c|c|r|r|r|", display=c("d","d","g","g","g"),caption=capt2)
print(xt3, include.rownames=FALSE)
ex_num_sol_init <- c(3,4,6,8)
assem <- c(20, 40, 60)
max_assem = max(assem)
max_subset_labels <- c(ex_num_sol_init, seq(from=10, to=max_assem/2, by=5))
max_rows <- length(max_subset_labels)
cnames <-c("Subset Size")
subsets <- data.frame(matrix(ncol=0,nrow=max_rows))
# The subset sizes are the first column
subsets <- cbind(subsets, max_subset_labels)
# Create columns for each assemblage size, picking out the {n,k} for the desired subset sizes
for(n in assem) {
# add the assemblage size as a colname
cnames <- c(cnames, as.character(n))
# calculate additional subset sizes based on the size of the assemblage, up to 1/2*N since {n,k} peaks there
more_subsets <- seq(from=10, to=n/2, by=10)
subsets_selected <- c(ex_num_sol_init, more_subsets)
# calculate the stirling numbers of the second kind
# the output of stirling() is a zero-based array for substantive reasons,
# so to pull out the appropriate values in a 1-based array index language, add one to
# all indices...
stirl <- stirling(n)
col <- stirl[subsets_selected + 1]
# since this is a data frame, pad the rest of the column with NA
num_NA_needed <- max_rows - length(col)
col <- c(col, rep(NA_integer_, num_NA_needed))
subsets <- cbind(subsets, col)
}
colnames(subsets) <- cnames
capt2 <- paste("Number of ways to form M seriation solutions from 20-60 assemblages")
xt3 <- xtable(subsets, align="|c|c|r|r|r|", display=c("d","d","g","g","g"),caption=capt2)
print(xt3, include.rownames=FALSE)
viewData(subsets)
viewData(subsets)
ex_num_sol_init <- c(3,4,6,8)
assem <- c(20, 40, 60)
max_assem <- max(assem)
subset_incr <- 5
max_subset_labels <- c(ex_num_sol_init, seq(from=10, to=max_assem/2, by=subset_incr))
max_rows <- length(max_subset_labels)
cnames <-c("Subset Size (m)")
subsets <- data.frame(matrix(ncol=0,nrow=max_rows))
# The subset sizes are the first column
subsets <- cbind(subsets, max_subset_labels)
# Create columns for each assemblage size, picking out the {n,k} for the desired subset sizes
for(n in assem) {
# add the assemblage size as a colname
cnames <- c(cnames, as.character(n))
# calculate additional subset sizes based on the size of the assemblage, up to 1/2*N since {n,k} peaks there
more_subsets <- seq(from=10, to=n/2, by=subset_incr)
subsets_selected <- c(ex_num_sol_init, more_subsets)
# calculate the stirling numbers of the second kind
# the output of stirling() is a zero-based array for substantive reasons,
# so to pull out the appropriate values in a 1-based array index language, add one to
# all indices...
stirl <- stirling(n)
col <- stirl[subsets_selected + 1]
# since this is a data frame, pad the rest of the column with NA
num_NA_needed <- max_rows - length(col)
col <- c(col, rep(NA_integer_, num_NA_needed))
subsets <- cbind(subsets, col)
}
colnames(subsets) <- cnames
capt2 <- paste("Number of ways to form m subsets (seriation solutions) from 20, 40, and 60 assemblages")
xt3 <- xtable(subsets, align="|c|c|r|r|r|", display=c("d","d","g","g","g"),caption=capt2)
print(xt3, include.rownames=FALSE)
viewData(subsets)
viewData(subsets)
factorial(20)
stirling(20)[3]
stirling(20)[4]
library(ggplot2)
library(randtoolbox)
library(xtable)
setwd("~/Dropbox/Research/Dissertation Project/src/Seriation/R")
setwd("~/Dropbox/Research/Dissertation Project/src/Seriation/analysis/R")
assem <- 40
numsubset <- stirling(assem)
subset_size <- seq(from=0, to=assem, by=1)
perm_per_subset_size <- factorial(assem-subset_size-1)
# remove the final NaN for subset {N,N}
perm_per_subset_size[is.nan(perm_per_subset_size)] <- 0
total_soln_per_subset_size <- numsubset * perm_per_subset_size
total_solutions <- sum(total_soln_per_subset_size)
print(total_solutions)
fix(perm_per_subset_size)
fix(perm_per_subset_size)
total_solutions_mult_groups <- function(n) {
num_subsets <- stirling(assem)
subset_size <- seq(from=0, to=assem, by=1)
# permutations
perm_per_subset_size <- factorial(assem-subset_size-1)
# remove the final NaN for subset {N,N}
perm_per_subset_size[is.nan(perm_per_subset_size)] <- 0
total_soln_per_subset_size <- numsubset * perm_per_subset_size
total_solutions <- sum(total_soln_per_subset_size)
total_solutions
}
total_solutions_mult_groups(40)
total_solutions_mult_groups(50)
total_solutions_mult_groups(60)
total_solutions_mult_groups <- function(n) {
num_subsets <- stirling(n)
subset_size <- seq(from=0, to=assem, by=1)
# permutations
perm_per_subset_size <- factorial(n-subset_size-1)
# remove the final NaN for subset {N,N}
perm_per_subset_size[is.nan(perm_per_subset_size)] <- 0
total_soln_per_subset_size <- numsubset * perm_per_subset_size
total_solutions <- sum(total_soln_per_subset_size)
total_solutions
}
total_solutions_mult_groups(60)
total_solutions_mult_groups(50)
total_solutions_mult_groups(40)
install.packages('inline')
install.packages('Rcpp')
library(inline)
library(Rcpp)
src <- '
std::vector<std::string> s;
s.push_back("hello");
s.push_back("world");
return Rcpp::wrap(s);
'
hellofun <- cxxfunction(body = src, includes = '', plugin = 'Rcpp', verbose = FALSE)
cat(hellofun(), '\n')
cat(hellofun(), '\n')
cat(hellofun(), '\n')
cat(hellofun(), '\n')
hellofun
